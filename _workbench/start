#!/bin/bash

PROJECT_DIR="$(cd "$(dirname "$0")" && pwd)"
PROJECT_NAME="$(basename "$PROJECT_DIR")"
WORKBENCH_DIR="$(cd "$PROJECT_DIR/../.." && pwd)/_workbench"
WATCHER_DIR="$PROJECT_DIR/.watcher"
SESSION_NAME="$PROJECT_NAME"

GLOBAL_PROMPT="$WORKBENCH_DIR/PROMPT.md"
PROJECT_PROMPT="$PROJECT_DIR/PROMPT.md"

json_escape() {
    local str="$1"
    str="${str//\\/\\\\}"
    str="${str//\"/\\\"}"
    str="${str//$'\n'/\\n}"
    str="${str//$'\r'/\\r}"
    str="${str//$'\t'/\\t}"
    echo "$str"
}

check_dependencies() {
    if ! command -v zellij &> /dev/null; then
        echo "zellij is not installed. Install: brew install zellij"
        exit 1
    fi
    if ! command -v fswatch &> /dev/null; then
        echo "fswatch is not installed. Install: brew install fswatch"
        exit 1
    fi
}

is_session_running() {
    zellij list-sessions 2>/dev/null | grep -q "$SESSION_NAME"
}

zj() {
    zellij --session "$SESSION_NAME" action "$@"
}

cleanup() {
    echo "Cleaning up..."
    pkill -f "fswatch.*$PROJECT_DIR" 2>/dev/null
    rm -f "$WATCHER_DIR/watcher.pid"
}

start_session() {
    check_dependencies

    # Create watcher directory first
    mkdir -p "$WATCHER_DIR"
    touch "$WATCHER_DIR/watcher.log"

    # Clean up tab markers from previous session
    find "$PROJECT_DIR/agents" -name ".tab-created" -delete 2>/dev/null

    echo "Starting session '$SESSION_NAME'..."

    # Start watcher in background first
    start_watcher &
    local watcher_pid=$!
    echo "$watcher_pid" > "$WATCHER_DIR/watcher.pid"

    # Cleanup on exit
    trap cleanup EXIT

    # Start zellij session with layout (tab name "_", cwd = PROJECT_DIR)
    cd "$PROJECT_DIR"
    zellij -s "$SESSION_NAME" -n "$WORKBENCH_DIR/layout.kdl"

    # This runs after zellij exits
    cleanup
}

get_status_from_path() {
    local path="$1"
    if [[ "$path" == to-do/* ]]; then echo "to-do"
    elif [[ "$path" == in-progress/* ]]; then echo "in-progress"
    elif [[ "$path" == in-review/* ]]; then echo "in-review"
    elif [[ "$path" == done/* ]]; then echo "done"
    elif [[ "$path" == cancelled/* ]]; then echo "cancelled"
    else echo ""
    fi
}

get_task_name_from_path() {
    local path="$1"
    local filename=$(basename "$path")
    echo "${filename%.*}"  # Remove extension
}

handle_task_event() {
    local relative_path="$1"
    local event_flags="$2"
    local file_content="$3"

    local status=$(get_status_from_path "$relative_path")
    if [ -z "$status" ]; then
        return
    fi

    local task_name=$(get_task_name_from_path "$relative_path")
    local task_file="$PROJECT_DIR/$relative_path"

    # If status is to-do, move to in-progress and wait for new event
    if [ "$status" = "to-do" ]; then
        local new_file="$PROJECT_DIR/in-progress/$(basename "$relative_path")"
        mv "$task_file" "$new_file"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] Moved task to in-progress: $task_name" >> "$WATCHER_DIR/watcher.log"
        return  # fswatch will trigger new event for in-progress
    fi

    local agent_dir="$PROJECT_DIR/agents/$task_name"
    local tab_name="$task_name/$status"

    # Create agent directory
    mkdir -p "$agent_dir"

    # Save task info to JSON file
    cat > "$agent_dir/task.json" << TASKJSON
{
  "path": "$relative_path",
  "event": "$event_flags",
  "status": "$status",
  "task_file": "$task_file"
}
TASKJSON

    # Log
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] Task: $task_name, Status: $status" >> "$agent_dir/log"

    # Check if tab was already created for this task (using marker file)
    local tab_marker="$agent_dir/.tab-created"

    if [ -f "$tab_marker" ]; then
        # Tab exists - find it and rename
        for old_status in "to-do" "in-progress" "in-review" "done" "cancelled"; do
            local old_tab_name="$task_name/$old_status"
            if [ "$old_tab_name" != "$tab_name" ]; then
                zj go-to-tab-name "$old_tab_name" 2>/dev/null
                zj rename-tab "$tab_name" 2>/dev/null
            fi
        done
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] Tab already exists for: $task_name (status: $status)" >> "$WATCHER_DIR/watcher.log"
        return
    fi

    # Only start agent for in-progress tasks
    if [ "$status" != "in-progress" ]; then
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] Ignoring non-in-progress task without tab: $task_name ($status)" >> "$WATCHER_DIR/watcher.log"
        return
    fi

    # No existing tab - create new one with claude

    # Build system prompt from global and project PROMPT files
    local system_prompt=""
    if [ -f "$GLOBAL_PROMPT" ]; then
        system_prompt=$(cat "$GLOBAL_PROMPT")
    fi
    if [ -f "$PROJECT_PROMPT" ]; then
        if [ -n "$system_prompt" ]; then
            system_prompt="$system_prompt"$'\n\n---\n\n'
        fi
        system_prompt="$system_prompt$(cat "$PROJECT_PROMPT")"
    fi

    # Read task content (only the part above the separator '----------')
    local task_content=""
    if [ -f "$task_file" ]; then
        # Extract content above the separator (10 hyphens)
        task_content=$(sed -n '/^----------$/q;p' "$task_file")
    fi

    # Get location target
    local location_target=""
    if [ -L "$PROJECT_DIR/location" ]; then
        location_target=$(readlink "$PROJECT_DIR/location")
    fi

    # Build the user prompt with task context
    local user_prompt="# Task Execution Request

## Environment
- **Project Root**: $PROJECT_DIR (your current working directory)
- **Source Code**: $PROJECT_DIR/location â†’ $location_target
- **Agent Workspace**: $PROJECT_DIR/agents/$task_name/

## Task Info
- **Name**: $task_name
- **Status**: $status
- **Task File**: $task_file

## Task Content
$task_content

## Instructions
1. The source code you need to work on is at \`location/\` (symlink to the actual repository)
2. Create a git worktree for your changes:
   \`\`\`bash
   git -C $PROJECT_DIR/location worktree add $agent_dir/worktree -b task/$task_name
   \`\`\`
3. Do your work in \`$agent_dir/worktree/\`
4. Log your progress to \`$agent_dir/log\`
5. When done, write your result summary to the task file below the separator line (\`----------\`)
6. Move the task file to \`done/\` (or \`in-review/\` if human review needed)"

    # Save system prompt to file for claude to use
    echo "$system_prompt" > "$agent_dir/system-prompt.txt"

    # Save user prompt to file
    echo "$user_prompt" > "$agent_dir/user-prompt.txt"

    # Create new tab with task name/status (cwd = PROJECT_DIR)
    zj new-tab --name "$tab_name" --cwd "$PROJECT_DIR"
    touch "$tab_marker"
    sleep 0.5

    # Name the left pane "agent"
    zj rename-pane "agent"

    # Split vertically (creates right pane for user)
    zj new-pane --direction right --name "user"

    # Helper to send text + Enter to agent pane
    send_to_agent() {
        # Ensure we're on the right tab and pane
        zj go-to-tab-name "$tab_name" 2>/dev/null
        zj move-focus left
        sleep 0.1
        zj write-chars "$1"
        sleep 0.1
        zj write 13  # Enter key (CR)
    }

    # Start claude interactively with system prompt
    send_to_agent "claude --dangerously-skip-permissions --system-prompt \"\$(cat agents/$task_name/system-prompt.txt)\""

    # Wait for claude to start
    sleep 2

    # Check if confirmation is needed by examining screen content
    local screen_content
    screen_content=$(zellij --session "$SESSION_NAME" action dump-screen 2>/dev/null || echo "")
    if echo "$screen_content" | grep -qiE "trust|Trust this project|y/n|\[y\]|Are you sure"; then
        send_to_agent "y"
        sleep 1
    fi

    # Send the task instruction (use absolute path)
    send_to_agent "Read and execute the task from $agent_dir/user-prompt.txt"

    echo "[$(date '+%Y-%m-%d %H:%M:%S')] Created tab: $tab_name, sent task to claude" >> "$WATCHER_DIR/watcher.log"
}

start_watcher() {
    # Wait for session to start
    for i in {1..30}; do
        if is_session_running; then
            break
        fi
        sleep 0.5
    done

    echo "[$(date '+%Y-%m-%d %H:%M:%S')] Watcher started" >> "$WATCHER_DIR/watcher.log"

    fswatch -x --event Created --event Updated --event Removed --event Renamed --exclude "location" --exclude ".watcher" --exclude "agents" --exclude "start" --exclude "metadata" --exclude "PROMPT.md" -r "$PROJECT_DIR" 2>/dev/null | while read -r line; do
        changed_file=$(echo "$line" | awk '{print $1}')
        event_flags=$(echo "$line" | cut -d' ' -f2-)

        # Skip unwanted paths
        if [[ "$changed_file" == "$PROJECT_DIR/location"* ]]; then continue; fi
        if [[ "$changed_file" == "$PROJECT_DIR/agents"* ]]; then continue; fi
        if [[ "$changed_file" == "$PROJECT_DIR/.watcher"* ]]; then continue; fi

        if ! is_session_running; then
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] Session not running, stopping" >> "$WATCHER_DIR/watcher.log"
            break
        fi

        relative_path="${changed_file#$PROJECT_DIR/}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] File: $relative_path ($event_flags)" >> "$WATCHER_DIR/watcher.log"

        file_content=""
        if [ -f "$changed_file" ]; then
            file_content=$(cat "$changed_file")
        fi

        handle_task_event "$relative_path" "$event_flags" "$file_content"
    done
}

# Kill existing session and start fresh
if is_session_running; then
    echo "Killing existing session '$SESSION_NAME'..."
    zellij kill-session "$SESSION_NAME" 2>&1 >/dev/null
    pkill -f "fswatch.*$PROJECT_DIR" 2>/dev/null
    rm -f "$WATCHER_DIR/watcher.pid"

    # Wait until session is fully terminated
    for i in {1..20}; do
        if ! is_session_running; then
            break
        fi
        sleep 0.2
    done

    # Force kill if still running
    if is_session_running; then
        echo "Force killing session..."
        zellij delete-session "$SESSION_NAME" --force 2>&1 >/dev/null
        sleep 0.5
    fi
fi
start_session
